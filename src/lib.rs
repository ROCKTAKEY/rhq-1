extern crate toml;
extern crate walkdir;
extern crate shellexpand;
extern crate regex;
extern crate url;
#[macro_use]
extern crate log;
#[macro_use]
extern crate serde_derive;
#[macro_use]
extern crate error_chain;

use std::borrow::{Borrow, Cow};
use std::path::Path;
use walkdir::WalkDirIterator;
use regex::Regex;
use url::Url;
use config::Config;

pub fn resolve_query(query: &str) -> errors::Result<url::Url> {
  let re_hasscheme = Regex::new(r"^[^:]+://").unwrap();
  let re_scplike = Regex::new(r"^((?:[^@]+@)?)([^:]+):/?(.+)$").unwrap();

  let url: Cow<str> = if re_hasscheme.is_match(query) {
    info!("has scheme");
    query.into()
  } else if let Some(cap) = re_scplike.captures(query) {
    info!("SCP-like");
    let username = cap.get(1)
      .and_then(|s| if s.as_str() != "" {
        Some(s.as_str())
      } else {
        None
      })
      .unwrap_or("git@");
    let host = cap.get(2).unwrap().as_str();
    let path = cap.get(3).unwrap().as_str();
    format!("ssh://{}{}/{}.git", username, host, path).into()
  } else {
    info!("query");
    if let Some(_) = query.split("/").next().and_then(|host| match host {
      "github.com" | "bitbucket.org" | "gitlab.com" => Some(host),
      _ => None,
    }) {
      format!("https://{}.git", query).into()
    } else {
      format!("https://github.com/{}.git", query).into()
    }
  };
  Url::parse(url.borrow()).map_err(Into::into)
}

#[cfg(test)]
mod tests {
  use super::resolve_query;

  #[test]
  fn test_hostpattern() {
    let result = resolve_query("https://github.com/peco/peco.git");
    assert!(result.is_ok());

    let result = result.unwrap();
    assert_eq!(result.scheme(), "https");
    assert_eq!(result.username(), "");
    assert_eq!(result.password(), None);
    assert_eq!(result.host_str(), Some("github.com"));
    assert_eq!(result.path(), "/peco/peco.git");
  }

  #[test]
  fn test_ssh_hostpattern() {
    let result = resolve_query("ssh://gituser@github.com:2222/peco/peco.git");
    assert!(result.is_ok());

    let result = result.unwrap();
    assert_eq!(result.scheme(), "ssh");
    assert_eq!(result.username(), "gituser");
    assert_eq!(result.password(), None);
    assert_eq!(result.host_str(), Some("github.com"));
    assert_eq!(result.port(), Some(2222));
    assert_eq!(result.path(), "/peco/peco.git");
  }

  #[test]
  fn test_scplike_pattern() {
    let result = resolve_query("git@github.com:peco/peco");
    assert!(result.is_ok());

    let result = result.unwrap();
    assert_eq!(result.scheme(), "ssh");
    assert_eq!(result.username(), "git");
    assert_eq!(result.password(), None);
    assert_eq!(result.host_str(), Some("github.com"));
    assert_eq!(result.path(), "/peco/peco.git");
  }

  #[test]
  fn test_shortpattern1() {
    let result = resolve_query("github.com/peco/peco");
    assert!(result.is_ok());

    let result = result.unwrap();
    assert_eq!(result.scheme(), "https");
    assert_eq!(result.username(), "");
    assert_eq!(result.password(), None);
    assert_eq!(result.host_str(), Some("github.com"));
    assert_eq!(result.path(), "/peco/peco.git");
  }

  #[test]
  fn test_shortpattern2() {
    let result = resolve_query("peco/peco");
    assert!(result.is_ok());

    let result = result.unwrap();
    assert_eq!(result.scheme(), "https");
    assert_eq!(result.username(), "");
    assert_eq!(result.password(), None);
    assert_eq!(result.host_str(), Some("github.com"));
    assert_eq!(result.path(), "/peco/peco.git");
  }
}

pub fn list_repositories() -> errors::Result<()> {
  let config = Config::load()?;
  warn!("{:?}", config);

  let repos = walkdir::WalkDir::new(&config.root)
    .follow_links(true)
    .into_iter()
    .filter_entry(|ref entry| {
      entry.path()
        .parent()
        .map(|path| detect_vcs(&path).is_none())
        .unwrap_or(true)
    })
    .filter_map(Result::ok)
    .filter(|ref entry| detect_vcs(entry.path()).is_some());

  for repo in repos {
    println!("{}", repo.path().display());
  }

  Ok(())
}

fn detect_vcs(path: &Path) -> Option<&'static str> {
  [".git", ".svn", ".hg", "_darcs"]
    .into_iter()
    .find(|vcs| path.join(vcs).exists())
    .map(|s| *s)
}

/// defines error types (automatically generated by error_chain)
pub mod errors {
  error_chain!{
    foreign_links {
      Io(::std::io::Error);
      TomlDe(::toml::de::Error);
      ShellExpand(::shellexpand::LookupError<::std::env::VarError>);
      UrlParse(::url::ParseError);
    }
  }
}

/// defines configuration
pub mod config {
  use std::fs::File;
  use std::io::Read;
  use std::path::{Path, PathBuf};
  use toml;
  use shellexpand;
  use errors::Result;

  #[derive(Default, Deserialize)]
  struct RawConfig {
    root: Option<String>,
  }

  impl RawConfig {
    fn from_file<P: AsRef<Path>>(path: P) -> Result<Option<RawConfig>> {
      if !path.as_ref().is_file() {
        return Ok(None);
      }

      let mut content = String::new();
      File::open(path)?.read_to_string(&mut content)?;
      Ok(Some(toml::from_str(&content).ok().unwrap_or_default()))
    }

    fn merge(&mut self, other: RawConfig) {
      if let Some(root) = other.root {
        self.root = Some(root);
      }
    }
  }

  fn read_all_config() -> Result<RawConfig> {
    #[cfg_attr(rustfmt, rustfmt_skip)]
    const DEFAULT_CONFIG: &'static str =
      include_str!(concat!(env!("CARGO_MANIFEST_DIR"), "/rhqconfig"));

    #[cfg_attr(rustfmt, rustfmt_skip)]
    const CANDIDATES: &'static [&'static str] =
      &["~/.config/rhq/config", "~/.rhqconfig"];

    let mut config: RawConfig = toml::from_str(DEFAULT_CONFIG)
      .expect("failed to decode default config");
    for path in CANDIDATES {
      let path = shellexpand::full(path).unwrap().into_owned();
      if let Some(conf) = RawConfig::from_file(path)? {
        config.merge(conf);
      }
    }

    Ok(config)
  }

  /// configuration load from config.toml
  #[derive(Debug)]
  pub struct Config {
    pub root: PathBuf,
  }

  impl Config {
    pub fn load() -> Result<Config> {
      let raw_config = read_all_config()?;

      let root = raw_config.root.expect("entry 'root' is not found");
      let root = PathBuf::from(shellexpand::full(&root)?.into_owned());

      Ok(Config { root: root })
    }
  }
}
