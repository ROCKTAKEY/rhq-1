extern crate toml;
extern crate shellexpand;
#[macro_use]
extern crate log;
#[macro_use]
extern crate serde_derive;
#[macro_use]
extern crate error_chain;

use config::Config;

/// run ghq application
pub fn run() -> errors::Result<()> {
  let config = Config::load()?;
  warn!("{:?}", config);
  Ok(())
}

/// defines error types (automatically generated by error_chain)
pub mod errors {
  error_chain!{
    errors {
      LoadConfig {
        description("cannot load configuration")
      }
    }
    foreign_links {
      Io(::std::io::Error);
      ShellExpand(::shellexpand::LookupError<::std::env::VarError>);
    }
  }
}

/// defines configuration
pub mod config {
  use std::fs::File;
  use std::io::Read;
  use std::path::{Path, PathBuf};
  use toml;
  use shellexpand;

  use errors::{Result, ErrorKind};

  const CANDIDATES: &'static [&'static str] =
    &["~/.config/rhq/config", "~/.rhqconfig", "rhqconfig"];

  #[derive(Default, Deserialize)]
  struct RawConfig {
    root: Option<String>,
  }

  impl RawConfig {
    fn from_file<P: AsRef<Path>>(path: P) -> Result<Option<RawConfig>> {
      if !path.as_ref().is_file() {
        return Ok(None);
      }

      let mut content = String::new();
      File::open(path)?.read_to_string(&mut content)?;
      Ok(Some(toml::from_str(&content).ok().unwrap_or_default()))
    }

    fn merge(&mut self, other: RawConfig) {
      if let Some(root) = other.root {
        self.root = Some(root);
      }
    }
  }

  /// configuration load from config.toml
  #[derive(Debug)]
  pub struct Config {
    pub root: PathBuf,
  }

  impl Config {
    pub fn load() -> Result<Config> {
      let mut raw_config: Option<RawConfig> = None;
      for path in CANDIDATES {
        let path = shellexpand::full(path)?.into_owned();
        if let Some(conf) = RawConfig::from_file(path)? {
          if let Some(ref mut raw_config) = raw_config {
            raw_config.merge(conf);
          } else {
            raw_config = Some(conf);
          }
        }
      }
      let raw_config = raw_config.ok_or(ErrorKind::LoadConfig)?;

      let root = raw_config.root.unwrap_or("~/.rhq".to_owned());
      let root = PathBuf::from(shellexpand::full(&root)?.into_owned());

      Ok(Config { root: root })
    }
  }
}
