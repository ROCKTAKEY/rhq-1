extern crate toml;
extern crate shellexpand;
#[macro_use]
extern crate log;
#[macro_use]
extern crate serde_derive;
#[macro_use]
extern crate error_chain;

use config::Config;

/// run ghq application
pub fn run() -> errors::Result<()> {
  let config = Config::load()?;
  warn!("{:?}", config);
  Ok(())
}

/// defines error types (automatically generated by error_chain)
pub mod errors {
  error_chain!{
    errors {
      LoadConfig {
        description("cannot load configuration")
      }
    }
    foreign_links {
      Io(::std::io::Error);
      ShellExpand(::shellexpand::LookupError<::std::env::VarError>);
    }
  }
}

/// defines configuration
pub mod config {
  use std::fs::File;
  use std::io::Read;
  use std::path::{Path, PathBuf};
  use toml;
  use shellexpand;
  use errors::{Result, ErrorKind};

  #[derive(Default, Deserialize)]
  struct RawConfig {
    root: Option<String>,
  }

  impl RawConfig {
    fn from_file<P: AsRef<Path>>(path: P) -> Result<Option<RawConfig>> {
      if !path.as_ref().is_file() {
        return Ok(None);
      }

      let mut content = String::new();
      File::open(path)?.read_to_string(&mut content)?;
      Ok(Some(toml::from_str(&content).ok().unwrap_or_default()))
    }

    fn merge(&mut self, other: RawConfig) {
      if let Some(root) = other.root {
        self.root = Some(root);
      }
    }
  }

  fn read_all_config() -> Result<RawConfig> {
    const CANDIDATES: &'static [&'static str] =
      &["~/.config/rhq/config", "~/.rhqconfig", "rhqconfig"];

    let mut config: Option<RawConfig> = None;

    for path in CANDIDATES {
      let path = shellexpand::full(path).unwrap().into_owned();
      let conf = match RawConfig::from_file(path)? {
        Some(conf) => conf,
        None => continue,
      };

      match config {
        Some(ref mut config) => config.merge(conf),
        None => config = Some(conf),
      }
    }

    config.ok_or(ErrorKind::LoadConfig).map_err(Into::into)
  }

  /// configuration load from config.toml
  #[derive(Debug)]
  pub struct Config {
    pub root: PathBuf,
  }

  impl Config {
    pub fn load() -> Result<Config> {
      let raw_config = read_all_config()?;

      let root = raw_config.root.unwrap_or("~/.rhq".to_owned());
      let root = PathBuf::from(shellexpand::full(&root)?.into_owned());

      Ok(Config { root: root })
    }
  }
}
